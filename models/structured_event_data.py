# generated by datamodel-codegen:
#   filename:  res2.json
#   timestamp: 2022-07-06T21:31:01+00:00

from __future__ import annotations

from typing import Any, List, Optional

from pydantic import BaseModel, Field


class Uri(BaseModel):
    url: str
    __typename: str


class LowestPrice(BaseModel):
    amount: int
    currency: str
    __typename: str


class OrganizerBrand(BaseModel):
    id: str
    name: str
    __typename: str


class Uri1(BaseModel):
    url: str
    __typename: str


class City(BaseModel):
    id: str
    name: str
    __typename: str


class Country(BaseModel):
    name: str
    code: str
    __typename: str


class Location(BaseModel):
    id: str
    uri: Uri1
    address: Any
    zipcode: Any
    name: str
    city: City
    country: Country
    __typename: str


class TotalPriceWithTransactionFee(BaseModel):
    amount: int
    currency: str
    __typename: str


class Price(BaseModel):
    total_price_with_transaction_fee: TotalPriceWithTransactionFee = Field(
        ..., alias='totalPriceWithTransactionFee'
    )
    __typename: str


class Uri2(BaseModel):
    url: str
    __typename: str


class Node2(BaseModel):
    id: str
    created_at: str = Field(..., alias='createdAt')
    price: Price
    uri: Uri2
    __typename: str


class Edge1(BaseModel):
    node: Node2
    __typename: str


class AvailableListings(BaseModel):
    edges: List[Edge1]
    __typename: str


class Node1(BaseModel):
    id: str
    available_listings: AvailableListings = Field(..., alias='availableListings')
    __typename: str


class Edge(BaseModel):
    node: Node1
    __typename: str


class Types(BaseModel):
    edges: List[Edge]
    __typename: str


class Node(BaseModel):
    id: str
    name: str
    status: str
    uri: Uri
    lowest_price: LowestPrice = Field(..., alias='lowestPrice')
    artists: List
    organizer_brands: List[OrganizerBrand] = Field(..., alias='organizerBrands')
    start_date: str = Field(..., alias='startDate')
    end_date: str = Field(..., alias='endDate')
    available_tickets_count: int = Field(..., alias='availableTicketsCount')
    location: Location
    types: Types
    __typename: str


class User(BaseModel):
    id: str
    avatar: str
    firstname: str
    __typename: str


class Node3(BaseModel):
    id: str
    rating: int
    user: User
    description: str
    created_at: str = Field(..., alias='createdAt')
    __typename: str


class Edge2(BaseModel):
    node: Node3
    __typename: str


class PageInfo(BaseModel):
    has_next_page: bool = Field(..., alias='hasNextPage')
    end_cursor: str = Field(..., alias='endCursor')
    __typename: str


class Testimonials(BaseModel):
    edges: List[Edge2]
    total_review_count: int = Field(..., alias='totalReviewCount')
    review_average: int = Field(..., alias='reviewAverage')
    page_info: PageInfo = Field(..., alias='pageInfo')
    __typename: str


class RandomUserAvatar(BaseModel):
    avatar: str
    __typename: str


class EventData(BaseModel):
    node: Optional[Node] = None
    testimonials: Optional[Testimonials] = None
    random_user_avatars: Optional[List[RandomUserAvatar]] = Field(
        None, alias='randomUserAvatars'
    )
    user_count: Optional[int] = Field(None, alias='userCount')


class EventItem(BaseModel):
    data: EventData


class StructuredEventResponse(BaseModel):
    data: List[EventItem]


    def get_event_ids(self) -> list[str]:
        ids: list[str] = []
        for event_item in self.data:
            try:
                for edge in event_item.data.node.types.edges:
                    try:
                        ids.append(edge.node.id)
                    except AttributeError:
                        continue
            except AttributeError:
                continue

        return ids
